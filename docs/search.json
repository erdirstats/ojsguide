[
  {
    "objectID": "ojsguide.html#intro",
    "href": "ojsguide.html#intro",
    "title": "Interactive output for geotechnical data with R/Python/Julia + OJS",
    "section": "Intro",
    "text": "Intro\nThis is a short step-by-step guide on how to create interactive output for geotechnical data using Observable JavaScript (OJS) combined with your go-to programming language for working with data (R, Python, or Julia). The main idea is to create content similar to the following examples:\n\nSoil unitisation viewer\nCPT data explorer\nSoil unit comparison\n\nThese types of documents can be used a lot in geotechnics, starting from exploring in-situ and laboratory data up to presenting output like design lines. Interactivity overcomes most of the challenges associated with the static way of presenting content.\n\n\n\n\n\n\nDisclaimer\n\n\n\nThis is not a thorough guide, and some key concepts only are shown. Much more material is shown in the links in this document.\n\n\n\n\n\n\n\n\nCommenting\n\n\n\nIf you have any comments/remarks on the content of this post, you can select the specific text and add Annotate or Highlight. The comments will appear on the top right of the page."
  },
  {
    "objectID": "ojsguide.html#workflow",
    "href": "ojsguide.html#workflow",
    "title": "Interactive output for geotechnical data with R/Python/Julia + OJS",
    "section": "Workflow",
    "text": "Workflow\nLet’s say we want to create some interactive output for some geotechnical data we have. To do this, we could think of the following workflow:\n\n\n\n\nflowchart LR\n  A[Data source] --&gt; B[Read/prepare data]\n  B --&gt; C[Visualize]\n  C --&gt; D[Enable interactivity]\n  D --&gt; E[Put all in an HTML]\n  E --&gt; F((Deploy/share))\n\n\n\n\n\nDepending on the type/size of the data, project, and our idea on how the final output should look, each of these steps may involve small or enormous amount of work. Let’s consider the Read/prepare data step. If the data we are reading are already formatted the way we want, no preparation is needed. Generally speaking, though, you would want/need to work a bit with the data.\nWhat tools can we use to complete each of these steps? The steps involving retrieving the data from a Data source and Read/prepare data would need writing some code. There are many options here. We could use R to complete these tasks or we could rather go for the difficult way, using Python or Julia.\n\n\n\n\nflowchart LR\n  A[Data source] --&gt; B[Read/prepare data]\n  B --&gt; C[Visualize]\n  C --&gt; D[Enable interactivity]\n  D --&gt; E[Put all in an HTML]\n  E --&gt; F((Deploy/share))\n  style A fill: #ffe3e3\n  style B fill: #ffe3e3\n\n\n\n\n\n\n\n\n\nflowchart LR\n  A[Data source] ---&gt; G & H & I\n  G[R] ---&gt;  B[Read/prepare data]\n  H[Python] ---&gt;  B[Read/prepare data]\n  I[Julia] ---&gt;  B[Read/prepare data]\n  style A fill: #ffe3e3\n  style B fill: #ffe3e3\n  style G fill: #ffe3e3\n  style H fill: #ffe3e3\n  style I fill: #ffe3e3\n\n\n\n\n\nThere are many options to Visualize data and to Enable interactivity. Here we are going to use OJS. OJS is a big platform but what we are mostly interested here is the Observable Plot package.\n\nObservable Plot is a free, open-source, JavaScript library for visualizing tabular data, focused on accelerating exploratory data analysis. It has a concise, memorable, yet expressive interface, featuring scales and layered marks in the grammar of graphics …\n\n\n\n\n\nflowchart LR\n  A[Data source] --&gt; B[Read/prepare data]\n  B --&gt; C[Visualize]\n  C --&gt; D[Enable interactivity]\n  D --&gt; E[Put all in an HTML]\n  E --&gt; F((Deploy/share))\n  style C fill: #ffe3e3\n  style D fill: #ffe3e3\n\n\n\n\n\n\n\n\n\nflowchart LR\n  J[OJS] ---&gt;  C[Visualize]\n  J[OJS] ---&gt;  D[Enable interactivity]\n  style C fill: #ffe3e3\n  style D fill: #ffe3e3\n  style J fill: #ffe3e3\n\n\n\n\n\nLastly, to Put all in an HTML and to Deploy/share our work, we use Quarto.\n\nAn open-source scientific and technical publishing system.\n\n\n\n\n\nflowchart LR\n  A[Data source] --&gt; B[Read/prepare data]\n  B --&gt; C[Visualize]\n  C --&gt; D[Enable interactivity]\n  D --&gt; E[Put all in an HTML]\n  E --&gt; F((Deploy/share))\n  style E fill: #ffe3e3\n  style F fill: #ffe3e3\n\n\n\n\n\n\n\n\n\nflowchart LR\n  K[Quarto] ---&gt;  E[Put all in an HTML]\n  K[Quarto] ---&gt;  F((Deploy/share))\n  style E fill: #ffe3e3\n  style F fill: #ffe3e3\n  style K fill: #ffe3e3\n\n\n\n\n\nQuarto provides what we need: ease to create and publish HTML content. Most importantly though, it enables combining R, Python, Julia and OJS within the same document. This means that we can complete all the workflow within the Quarto ecosystem.\n\n\n\n\nflowchart TB\n  K[Quarto] --&gt;  A[Data source]\n  K[Quarto] --&gt;  B[Read/prepare data]\n  K[Quarto] --&gt;  C[Visualize]\n  K[Quarto] --&gt;  D[Enable interactivity]\n  K[Quarto] --&gt;  E[Put all in an HTML]\n  K[Quarto] --&gt;  F((Deploy/share))\n  style K fill: #ffe3e3"
  },
  {
    "objectID": "ojsguide.html#example",
    "href": "ojsguide.html#example",
    "title": "Interactive output for geotechnical data with R/Python/Julia + OJS",
    "section": "Example",
    "text": "Example\nLet’s create a minimal example using the workflow/tools we presented above. The source of the data is an AGS file. We are using Python to work with the data and VS Code as the IDE.\n\n\n\n\n\n\nNote\n\n\n\nThis is one of many possible paths. There are several options.\n\n\n\nStep 01: Setup\nSetting up the working environment involves:\n\nInstall PowerShell, Windows Terminal, VS Code, Git, Pyenv, and Poetry. There is an NGI Code Academy guide that covers all this.\nDownload and install Quarto.\nDownload and install the Quarto extension for VS Code.\n\n\n\nStep 02: Start project\nStart the project by doing one of the following:\n\nCreate a python project using poetry, or, alternatively\nCreate a repository in GitHub / Azure and clone it locally.\n\n\n\nStep 03: Create a .qmd document\n\nQuarto files end with the .qmd extension.\nA .qmd file is basically a notebook: it combines markdown text with code chunks.\nAt the very start of a .qmd file we have the YAML which sets the scene for what we want to do with this file (e.g., what kind of output we want to have). An example YAML can be:\n\n---\ntitle: \"OJS for geodata\"\nsubtitle: \"Interactive output for geotechnical data with R/Python/Julia + OJS\"\nauthor: EMy\nformat: html\n---\n\nBelow the YAML we have the other content:\n\nmarkdown text: to explain stuff, and\ncode chunks: to do stuff.\n\n\n```{python}\n# this is a python code chunk\n# here we write python code\n```\n```{ojs}\n// this is a OJS code chunk\n// here we write OJS code\n```\n\n\nStep 04: Work with the data\nWe read an AGS file and extract the CPT locations (group LOCA). The data are then saved locally in a CSV file. All this work is done with python, so the actual code is placed within python code chunks (which start with ```{python}).\n\nCodeOutput\n\n\n1import polars as pl\nfrom python_ags4 import AGS4\n2tables, headings = AGS4.AGS4_to_dataframe('data/HKW_20190902_FNLM_CPT_AGS4.0_V02_F.ags')\nLOCA = AGS4.convert_to_numeric(tables['LOCA'])\n3LOCA = pl.from_pandas(LOCA)\nLOCA.write_csv('csv/LOCA.csv')\n\n1\n\nImport packages.\n\n2\n\nRead AGS.\n\n3\n\nConvert to polars DF and write CSV file.\n\n\n\n\n\n\n\n\n\n\nStep 05: Plot\nWe now leave Python and jump to OJS and more specifically to Observable Plot. The OJS code is written inside the respective code chunks, which start with ```{ojs}. Initially let’s load the brand-new CSV file into OJS.\n\nRead CSVLOCALOCA table\n\n\n\n\nCode\nLOCA = FileAttachment('csv/LOCA.csv').csv({typed: true})\n\n\n\n\n\n\n\n\n\n\n\nCode\nLOCA\n\n\n\n\n\n\n\n\n\n\n\nCode\nInputs.table(LOCA)\n\n\n\n\n\n\n\n\n\n\nIf we look at the LOCA tab above, we see that OJS presents the data in similar way to JSON data format. To view this data in a more traditional table-like format we use Inputs.table(LOCA) code (see the LOCA table tab).\nWe can plot a location map of the CPTs, using Observable Plot:\n\n\nCode\nPlot.plot({\n    marks: [\n        Plot.dot(\n          LOCA,\n          {\n            x: \"LOCA_NATE\",\n            y: \"LOCA_NATN\",\n            r: 4,\n            stroke: \"blue\"\n          }\n        )\n  ]\n})\n\n\n\n\n\n\n\n\n\nStep 06: Interactivity\nThere is nothing interactive about the previous plot. We might want, for example, to have a slider that allows to change the size of the dots. How to add such interactivity?\nFor this, we use Inputs.\n\nThese lightweight interface components — buttons, sliders, dropdowns, tables, and the like — help you explore data and build interactive displays.\n\nThere are many type of Inputs and each of them allows us to interact with the plots in a specific way. The most basic type is a numeric range:\n\n\nCode\nviewof x = Inputs.range()\n\nx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can further customise the previous Input by specifying:\n\nname: dotsize\nrange: [0, 40]\ndefault value: 5\nstep: 1, and\nlabel: Size of dot:.\n\n\n\nCode\nviewof dotsize= Inputs.range(\n    [0, 40],\n    {\n        value: 5,\n        step: 1,\n        label: \"Size of dot:\"\n    }\n)\n\ndotsize\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe need to connect this slider with the previous plot. To do this, we use the name of the slider dotsize and refer it in the plot code. In our case, we link the dotsize slider with the radius r in the plot code. Note that the following plot is responsive to changes in the slider.\n\n\nCode\nPlot.plot({\n    marks: [\n        Plot.dot(\n          LOCA,\n          {\n            x: \"LOCA_NATE\",\n            y: \"LOCA_NATN\",\n            r: dotsize, // it was 4 before,\n            stroke: \"blue\"\n          }\n        )\n  ]\n})\n\n\n\n\n\n\n\nOther interactive elements can be added to the plot. Let’s say we want:\n\nA color Input to change the color of the dots in the locations map.\nA select Input allowing us to select one or some CPT locations and highlighting the selected locations in the location map.\nA toggle Input allowing to show the location ID for the selected CPTs.\n\nThese Inputs would look like this:\n\n\nCode\nviewof dotcolor = Inputs.color({label: \"Color of dot:\"})\n\n// select locations\nviewof filt_loc = Inputs.select(\n    [null].concat(LOCA.map(d =&gt; d.LOCA_ID)),\n    {\n        multiple: 8,\n        label: \"Select:\",\n        sort: true,\n        unique: true\n    }\n)\n\n// filter selected locations\nLOCA_FILT = LOCA.filter(function(func_filt) {return filt_loc.includes(func_filt.LOCA_ID);})\n\n// location name\nviewof name = Inputs.toggle({label: \"Name?:\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinking these Inputs to the plot:\n\n\nCode\nPlot.plot({\n    marks: [\n        Plot.dot(\n            LOCA,\n            {\n                x: \"LOCA_NATE\",\n                y: \"LOCA_NATN\",\n                r: dotsize,\n                stroke: dotcolor\n            }\n        ),\n        Plot.dot(\n            LOCA_FILT, \n            {\n                x: \"LOCA_NATE\",\n                y: \"LOCA_NATN\",\n                symbol: \"times\",\n                r: 10,\n                stroke: \"LOCA_ID\",\n                strokeWidth: 5\n            }\n        ),\n        name ? Plot.text(\n            LOCA_FILT,\n            {\n                x: \"LOCA_NATE\",\n                y: \"LOCA_NATN\",\n                text: 'LOCA_ID',\n                fill: 'black',\n                stroke: 'white'\n            }\n        ) : null\n\n  ]\n})\n\n\n\n\n\n\n\n\n\nStep 07: Create HTML and publish\nTo render the HTML file including all our interactive (and also static) content, we run quarto render &lt;my_file_name&gt;.qmd in Terminal. There are many options to publish and share this HTML, e.g. Gitub Pages. We can’t go into details here, but the process is rather straightforward.\n\nThis is all."
  }
]